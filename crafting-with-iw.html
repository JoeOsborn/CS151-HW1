<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Craft Planning with Iterative Widening</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Craft Planning with Iterative Widening</h1>
<p>
This assignment is the second part of the planning problem sequence.
The first part is &ldquo;Path Planning Four Ways,&rdquo; which is a prerequisite for this section.
</p>

<p>
In this assignment, you will be making a simple satisficing Minecraft crafting planner.
Given an initial state, you will want to find a series of actions that gets you to a desired goal state. 
You will first try an implementation of generic graph search (Dijkstra&rsquo;s algorithm) to discover whether it is suitable for this task, and then implement a specialized planning algorithm called Iterative Widening.
</p>

<p>
In this assignment you will:
</p>

<ul class="org-ul">
<li>Parse and process a data file into a format that is usable in your code</li>
<li>Create a representation of a state space such that you can check preconditions and apply effects in an efficient manner</li>
<li>Create a method to convert the intuitive predicate based state system into a propositional system</li>
<li>Implement width-search via Iterative Widening to efficiently find a plan that gets from an arbitrary state space to a desired state space</li>
<li>Compare width-search to optimal search methods such as Dijkstra’s algorithm</li>
</ul>

<p>
The goal of this assignment is for you to understand:
</p>

<ul class="org-ul">
<li>How to manipulate data (a boring, but <i>crucial</i> skill)</li>
<li>How to navigate a state space that doesn’t map to standard geometry (i.e., domains outside of path planning)</li>
<li>How the pruning of a search space can result in a drastic reduction in the time spent performing the search</li>
</ul>

<p>
Let&rsquo;s get to work in <code>crafting.py</code>.
The automatic tests for this module are in <code>test_crafting.py</code>.
You can run them with <code>python test_crafting.py</code>.
Feel free to modify this file as you like to add tests, try out new examples, and so on.
</p>

<p>
First we need to load <code>crafting.json</code>, a json file that has a subset of the Minecraft recipes in it (with some abstractions to account for travel time to different raw materials).  
We&rsquo;ll also throw in some other imports we&rsquo;ll need later. 
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> json
<span style="color: #0000FF;">from</span> typing <span style="color: #0000FF;">import</span> NamedTuple, Dict, Tuple, Optional, Sequence, List
<span style="color: #0000FF;">import</span> array
<span style="color: #0000FF;">import</span> heapq
<span style="color: #0000FF;">import</span> time
<span style="color: #0000FF;">import</span> itertools

<span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'Crafting.json'</span>) <span style="color: #0000FF;">as</span> f:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">Crafting</span> = json.load(f)
<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">+END_SRC python</span>
k
You may want to <span style="color: #0000FF;">try</span> printing out some different information <span style="color: #0000FF;">from</span> =<span style="color: #BA36A5;">Crafting</span>= to get a feel <span style="color: #0000FF;">for</span> its schema:

<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">+BEGIN_SRC python</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Example</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">List of items that can be in your inventory:</span>
<span style="color: #0000FF;">print</span>(Crafting[<span style="color: #008000;">'Items'</span>])
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">example: ['bench', 'cart', ..., 'wood', 'wooden_axe', 'wooden_pickaxe']</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">List of items needed to be in your inventory at the end of the plan:</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">(okay to have more than this; some might be satisfied by initial inventory)</span>
<span style="color: #0000FF;">print</span>(Crafting[<span style="color: #008000;">'Goal'</span>])
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">{'stone_pickaxe': 2}</span>

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Dict of crafting recipes (each is a dict):</span>
<span style="color: #0000FF;">print</span>(Crafting[<span style="color: #008000;">'Recipes'</span>][<span style="color: #008000;">'craft stone_pickaxe at bench'</span>])
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">{ 'Produces': {'stone_pickaxe': 1},</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">'Requires': {'bench': True},</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">'Consumes': {'cobble': 3, 'stick': 2},</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">'Time': 1</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">}</span>
</pre>
</div>

<p>
Let&rsquo;s reflect a little bit in <code>crafting.txt</code>.
</p>
<ol class="org-ol">
<li>Do the recipe dictionaries in <code>crafting.json</code> all have the same set of keys?  Print out a few to find out, or read the JSON file.</li>
<li>What is similar about the <code>Initial</code>, <code>Goal</code>, <code>Produces</code>, <code>Consumes</code>, and <code>Requires</code> schema?  What is different about them?</li>
<li>Thinking back to your data structures class, what operations are involved in looking up a key in a dictionary data structure, and how does that compare to obtaining values from an array?</li>
<li>Look this up if you need to: What is the difference between a Python <code>List</code> of integers and a Python <code>array.array</code> of integers?</li>
</ol>

<p>
Let&rsquo;s proceed by using the same data representation for an inventory state (as in <code>Initial</code>), a partial inventory state (as in <code>Goal</code>, <code>Produces</code>, and <code>Consumes</code>), and the inventory query posed by <code>Requires</code>.
Because the speed of the inner loop is of supreme importance in graph search, we&rsquo;ll want to use an <code>array</code> of unsigned integers data representation for each of these (this may feel like premature optimization; email me if you want extra credit by comparing it with a simple dict-based representation).
In order to go back and forth between item names and item indices, let&rsquo;s define a couple of global variables:
</p>

<div class="org-src-container">
<pre class="src src-python">items_by_index: <span style="color: #BA36A5;">List</span>[<span style="color: #006FE0;">str</span>] = Crafting[<span style="color: #008000;">'Items'</span>]
items_to_indices: <span style="color: #BA36A5;">Dict</span>[<span style="color: #006FE0;">str</span>, <span style="color: #006FE0;">int</span>] = {
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   item: index <span style="color: #0000FF;">for</span> index, item <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(items_by_index)
}
</pre>
</div>

<p>
We&rsquo;ll wrap our array-of-items data structure in a convenience class called <code>State</code>.
Because we&rsquo;ll need to put =State=s into closed sets, priority queues, and so on, we&rsquo;ll need them to be hashable, equatable, and comparable.
We also will need to be adding and subtracting inventory states from each other later on, so we&rsquo;ll put that in there too.
A skeleton of this class is provided below, with some of the data handling code given.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">class</span> <span style="color: #6434A3;">State</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   items: array.array

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, items: Optional[Sequence[<span style="color: #006FE0;">int</span>]] = <span style="color: #D0372D;">None</span>) -&gt; <span style="color: #D0372D;">None</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">if</span> items <span style="color: #0000FF;">is</span> <span style="color: #0000FF;">not</span> <span style="color: #D0372D;">None</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Copying a state from an old state.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">This call to the array constructor creates an array of unsigned integers and initializes it from the contents of items.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">self</span>.items = array.array(<span style="color: #008000;">'I'</span>, items)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">self</span>.items = array.array(<span style="color: #008000;">'I'</span>, [0 <span style="color: #0000FF;">for</span> item <span style="color: #0000FF;">in</span> items_by_index])

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__add__</span>(<span style="color: #0000FF;">self</span>, other:<span style="color: #008000;">'State'</span>) -&gt; <span style="color: #008000;">'State'</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">s</span> = State(<span style="color: #0000FF;">self</span>.items)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">A. How do we add together the contents of two states?</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> s

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__sub__</span>(<span style="color: #0000FF;">self</span>, other:<span style="color: #008000;">'State'</span>) -&gt; <span style="color: #008000;">'State'</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">s</span> = State(<span style="color: #0000FF;">self</span>.items)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">B. How do we subtract one state from another?</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> s

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__ge__</span>(<span style="color: #0000FF;">self</span>, other: <span style="color: #008000;">'State'</span>) -&gt; <span style="color: #006FE0;">bool</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">C. How do we know whether one state (self) contains everything that's inside of another (other)? </span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">pass</span>

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__lt__</span>(<span style="color: #0000FF;">self</span>, other: <span style="color: #008000;">'State'</span>) -&gt; <span style="color: #006FE0;">bool</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">not</span> (<span style="color: #0000FF;">self</span> &gt;= other)

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__eq__</span>(<span style="color: #0000FF;">self</span>, other) -&gt; <span style="color: #006FE0;">bool</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">self</span>.items == other.items

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__hash__</span>(<span style="color: #0000FF;">self</span>) -&gt; <span style="color: #006FE0;">int</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">hsh</span> = 5381
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> s <span style="color: #0000FF;">in</span> <span style="color: #0000FF;">self</span>.items:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">hsh</span> = ((hsh &lt;&lt; 5) + hsh) + s
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> hsh

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__str__</span>(<span style="color: #0000FF;">self</span>) -&gt; <span style="color: #006FE0;">str</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">self</span>.to_dict().__str__()

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">to_dict</span>(<span style="color: #0000FF;">self</span>) -&gt; Dict[<span style="color: #006FE0;">str</span>, <span style="color: #006FE0;">int</span>]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> {items_by_index[idx]: <span style="color: #0000FF;">self</span>.items[idx]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> idx <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(<span style="color: #006FE0;">len</span>(<span style="color: #0000FF;">self</span>.items))}

<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #6434A3;">@classmethod</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">from_dict</span>(cls, item_dict: Dict[<span style="color: #006FE0;">str</span>, <span style="color: #006FE0;">int</span>]) -&gt; <span style="color: #008000;">'State'</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> cls([
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   item_dict.get(item, 0) <span style="color: #0000FF;">for</span> item <span style="color: #0000FF;">in</span> items_by_index
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   ])
</pre>
</div>

<p>
At this point we can already solve trivial problems:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Example</span>
<span style="color: #BA36A5;">initial</span> = {<span style="color: #008000;">'stone_pickaxe'</span>:1, <span style="color: #008000;">'ingot'</span>:2}
<span style="color: #BA36A5;">goal</span> = {<span style="color: #008000;">'ingot'</span>:1}
<span style="color: #0000FF;">assert</span>(initial &gt;= goal)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">"It worked!"</span>)
</pre>
</div>

<p>
Now that we have our state representation, we can rephrase the recipes in terms of what they need from the state.
Python has a useful datastructure---<code>namedtuple</code>&#x2014;we can use for this purpose, so we&rsquo;ll have a <code>namedtuple</code> type called <code>Recipe</code>.  
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Recipe</span>(NamedTuple):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   produces: State
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   consumes: State
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   requires: State
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   cost: <span style="color: #006FE0;">int</span>
</pre>
</div>

<p>
It acts like a tuple in that its data are laid out contiguously in memory and it is immutable, but it has convenient accessors.
Let&rsquo;s initialize a dictionary mapping names to recipes:
</p>

<div class="org-src-container">
<pre class="src src-python">recipes: <span style="color: #BA36A5;">Dict</span>[<span style="color: #006FE0;">str</span>, Recipe] = {}
<span style="color: #0000FF;">for</span> name, rule <span style="color: #0000FF;">in</span> Crafting[<span style="color: #008000;">'Recipes'</span>].items():
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">recipes</span>[name] = Recipe(
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   State.from_dict(rule.get(<span style="color: #008000;">'Produces'</span>, {})),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   State.from_dict(rule.get(<span style="color: #008000;">'Consumes'</span>, {})),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   State.from_dict({item: 1 <span style="color: #0000FF;">if</span> req <span style="color: #0000FF;">else</span> 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span><span style="color: #0000FF;">for</span> item, req <span style="color: #0000FF;">in</span> rule.get(<span style="color: #008000;">'Requires'</span>, {}).items()}),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   rule[<span style="color: #008000;">'Time'</span>]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   )
</pre>
</div>

<p>
Now we have our state representation and our action representation for the crafting domain.
Let&rsquo;s reflect.
</p>

<ol class="org-ol">
<li value="5">What was the state representation in the path planning assignment?</li>
<li>What was the action representation?</li>
<li>How many possible actions are there in the whole domain, and how many of those are possible in a given state?</li>
</ol>

<p>
In fact, we can consider any planning problem in terms of states and a transition relation between states and those actions which are valid in that state. 
If we&rsquo;re thinking about path planning as search on the graph of possible locations (with edges given by a connectedness relation), task planning can be seen as search on the graph of possible states (with edges given by the state transition relation).
Let&rsquo;s implement the transition relation now:
</p>

<div class="org-src-container">
<pre class="src src-python">
<span style="color: #0000FF;">def</span> <span style="color: #006699;">preconditions_satisfied</span>(state: State, recipe: Recipe) -&gt; <span style="color: #006FE0;">bool</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">D. What needs to be true about state and recipe?</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Feel free to use State's &gt;= method</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">apply_effects</span>(state: State, recipe: Recipe) -&gt; State:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">E. How do you make a new state out of a state and a recipe?</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Note, DO NOT change state in-place!</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">None</span>


</pre>
</div>

<p>
Let&rsquo;s try it.
</p>

<div id="outline-container-org741d56f" class="outline-2">
<h2 id="org741d56f"><span class="section-number-2">1</span> Planning via Graph Search</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li value="8">Consider your implementation of Dijkstra&rsquo;s algorithm.  What would need to change so it works on states-and-actions instead of locations-and-directions?</li>
</ol>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">plan_dijkstra</span>(initial: State, goal: State, limit:<span style="color: #006FE0;">int</span>) -&gt; Tuple[<span style="color: #006FE0;">int</span>, <span style="color: #006FE0;">int</span>, Optional[List[<span style="color: #006FE0;">str</span>]]]:    
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">start_time</span> = time.time()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">E. Implement it here!  When you find a solution, print out the number of nodes visited and the time it took to get there.  If you don't find a solution, print out the number of nodes visited and the time it took to fail. </span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Feel free to use or modify the solution printing routine from the last exercise.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Return a tuple of (nodes_visited, -1, None) if no path exists, or else a tuple of (nodes_visited, cost, path) where path is a list of recipe names.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">You should also use limit to avoid visiting too many nodes before returning _something_.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Finally, you can check whether a State _satisfies_ a goal by checking `state &gt;= goal` </span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">pass</span>
</pre>
</div>

<p>
To try it out:
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Example</span>
<span style="color: #0000FF;">print</span>(plan_dijkstra(State.from_dict({}),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   State.from_dict({<span style="color: #008000;">'stone_pickaxe'</span>:1}),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   200000))
<span style="color: #0000FF;">print</span>(plan_dijkstra(State.from_dict({<span style="color: #008000;">'bench'</span>:1,<span style="color: #008000;">'stone_pickaxe'</span>:1}),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   State.from_dict({<span style="color: #008000;">'ingot'</span>:1}),
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   200000))
</pre>
</div>

<ol class="org-ol">
<li value="9">Imagine applying A* here.  What heuristic would you want to use?  Is that heuristic admissible?  Is that a problem?</li>
<li>What&rsquo;s the largest planning problem (initial and goal state) you can think up which your Dijkstra&rsquo;s implementation can solve optimally within 30 seconds?  How many nodes does it visit and how long does it take in wall-clock time?</li>
</ol>
</div>
</div>

<div id="outline-container-org51efe85" class="outline-2">
<h2 id="org51efe85"><span class="section-number-2">2</span> Planning with Iterative Widening</h2>
<div class="outline-text-2" id="text-2">
<p>
Let&rsquo;s compare against a dedicated planning algorithm, rather than applying graph search naively.
Planning domains have some significant differences from general graph search problems&#x2014;let&rsquo;s reflect on what they might be.
</p>
<ol class="org-ol">
<li value="11">In graph search, what is the goal of a search?  How is that different from the goal of a planning problem?</li>
<li>In graph search, what are the preconditions for traversing an edge?  How does this differ in a planning problem?</li>
<li>In graph search, detecting cycles is relatively cheap.  Is that the case for planning problems?</li>
<li>Is there more than one type of &ldquo;cycle&rdquo; in our crafting planning problem?</li>
</ol>

<p>
Think about a recipe like making a stone pickaxe.
Every possible planning state either satisfies its preconditions or doesn&rsquo;t.
If this recipe were the only action, we could formulate the problem as a domain with just three <i>abstract</i> states&#x2014;one without a pickaxe and without the needed supplies, one without a pickaxe and with the needed supplies, and one with a pickaxe (and it doesn&rsquo;t matter what else is in the state).
</p>
<ol class="org-ol">
<li>If we had a domain with just two recipes (<i>punch for wood</i> and <i>wood planks</i>), what would be the abstract states in the sense used above?</li>
</ol>

<p>
We can automate the intuition of (15) by transforming our states into <i>combinations of propositions.</i>
A <i>proposition</i> here is a logical fact entailed by the state; for example &ldquo;I have at least one piece of wood,&rdquo; &ldquo;I have at least two pieces of wood,&rdquo; &ldquo;I have at least one plank&rdquo;, and so on.
Note that if we have two pieces of wood then we necessarily have one piece of wood as well!
<i>Iterative widening</i> is a planning algorithm which works by abstracting away differences between states and discarding states which are too similar to states which have been seen already in this iteration.
Two states are similar if they share some number of propositions in common&#x2014;so if the <i>width</i> measure is one, then when we have seen one state where we have at least one stick we subsequently ignore every other state we might find later with one or more sticks (we&rsquo;ll relax this a little to say &ldquo;any sufficiently different state is worth exploring&rdquo;&#x2014;so if it has at least a few propositions that are unique with respect to all seen combinations of a given width, we will consider it).
To regain completeness&#x2014;to always find a solution if one exists&#x2014;the size of the combinations of items considered in this similarity computation is gradually increased until a solution is found.
</p>

<p>
Returning to the problem of creating a stone pickaxe, any state which has a bench, three or more cobble, and two or more sticks is interchangeable.
It also produces a propositions stating that we have a stone pickaxe.
We need to know the full set of possibly interesting propositions in the world (for the purposes of applying recipes), so we want to accumulate both the propositions involved with making the recipe and its outputs.
In order to know what all the combinations of propositions might be during planning, we need to all the individual propositions that might come up.
We also need to be able to convert initial and goal states into sets of propositions, so we&rsquo;ll have a function to do that once we start our search algorithm: 
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Proposition</span>(NamedTuple):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   item: <span style="color: #006FE0;">int</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   at_least: <span style="color: #006FE0;">int</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">state_propositions</span>(state: State) -&gt; Set[Proposition]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   propositions: <span style="color: #BA36A5;">Set</span>[Proposition] = <span style="color: #006FE0;">set</span>()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">F. Do something for each item in state.  Output all propositions entailed by the state's contents</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> propositions

</pre>
</div>


<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Now let's get the propositions from the recipes</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">recipe_propositions</span>(recipe: Recipe) -&gt; Set[Proposition]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   propositions: <span style="color: #BA36A5;">Set</span>[Proposition] = <span style="color: #006FE0;">set</span>()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">G. Do something with recipe.consumes, recipe.produces, and recipe.requires.</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Emit, for this recipe, all the propositions entailed by the preconditions and the _minimal_ set of propositions embodied in the preconditions (i.e., don't need to output wood &gt;= 2, wood &gt;= 1, wood &gt;= 0 if the recipe creates 2 wood.)</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> propositions

<span style="color: #BA36A5;">recipe_propositions</span> = <span style="color: #006FE0;">set</span>()
<span style="color: #0000FF;">for</span> r <span style="color: #0000FF;">in</span> recipes.values():
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">recipe_propositions</span> |= recipe_to_propositions(r)
</pre>
</div>

<p>
We can capture the notion of &ldquo;ignoring states that are not different enough&rdquo; by using the idea of a closed set from the cycle prevention techniques in graph search.
Instead of checking that the newly expanded state is present in a set of seen states, we can check whether it offers any predicate combinations of width up to \(W\) we haven&rsquo;t already encountered at width bound \(W\).
Given the set of propositions that are important in our state, we want to create a list of all the propositions and combinations of up to \(W\) propositions.
When considering a newly expanded state \(s\), we find all of the unique combinations of propositions that are true in \(s\) and return the size of the smallest such combination; we compare this size against \(W\) and give up if it is too high.
</p>

<p>
For example:
</p>
<ul class="org-ul">
<li>If \(s\) was the first state we&rsquo;ve seen with <code>bench&gt;=1</code> it would have width 1; we use the closed set to determine whether a given combination has been seen before.</li>
<li>If \(s\) was the first state with <code>bench&gt;=1</code> and <code>wooden_axe&gt;=1</code> but no new atomic propositions, it would have width 2</li>
<li>If \(s\) has no unique combinations up to size \(W\), we say it has infinite width (which we can write as just W+1, since we ignore states wider than \(W\)).</li>
<li>If the width of \(s\) is greater than \(W\), we do not add it to the open queue.</li>
</ul>

<p>
Provided is a snippet that will check whether a state satisfies a set representing a combination of propositions.
It will be useful in determining whether a state is novel.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Example, assuming propositions is a Set[Proposition]</span>
state_props:<span style="color: #BA36A5;">Set</span>[Proposition] = state_propositions(state)
<span style="color: #0000FF;">if</span> state_props.issuperset(propositions):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">pass</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">The state has this combination!</span>
<span style="color: #0000FF;">else</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">pass</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">The state does not!</span>
</pre>
</div>

<p>
Now you are equipped to implement iterative widening search.
For each instance of the search, you will want to keep track of all the witnessed combinations of propositions; this can be a set of sets (well, a set of <code>FrozenSets</code>, a Python type for an immutable set).
To update this set, you will implement a function <code>see_state(s:State, combinations:List[FrozenSet[Proposition]], seen_combinations:Set[FrozenSet[Proposition]]) -&gt; bool</code> which will take in a state, a list of combinations (sets of Propositions), and the seen set and output whether any new combinations were witnessed in this state.
Note that one state might lead to the discovery of several new combinations.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">see_state</span>(state:State, combinations:List[Set[Proposition]], seen_combinations:Set[FrozenSet[Proposition]]) -&gt; <span style="color: #006FE0;">bool</span>:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">any_new</span> = <span style="color: #D0372D;">False</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">state_props</span> = state_propositions(state)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> combo <span style="color: #0000FF;">in</span> combinations:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">H. Is this combination already in seen_combinations?</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">I. If not, it's novel; so is this combination a subset of the state_props?</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">pass</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> any_new
</pre>
</div>

<p>
The outer loop of iterative widening gradually increases the bound \(W\) up to a given \(WMax\).
The inner loop has the same skeleton as a standard graph search, with the exception that non-novel states are immediately thrown away.
For now, implement iterative widening&rsquo;s inner loop using breadth-first search.
</p>

<p>
Your search should return the sequence of actions required to reach a goal condition from an initial condition, along with the cost of that plan.
You also may want to print output describing how many nodes are visited and how much time has been taken for each value of \(W\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">plan_width</span>(initial: State, goal: State, WMax: <span style="color: #006FE0;">int</span>) -&gt; Tuple[<span style="color: #006FE0;">int</span>, <span style="color: #006FE0;">int</span>, Optional[List[<span style="color: #006FE0;">str</span>]]]:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">start_time</span> = time.time()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">all_propositions</span> = recipe_propositions | state_propositions(initial) | state_propositions(goal)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   all_combinations: List[FrozenSet[Proposition]] = []
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Increase W up to WMax</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">for</span> W <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, WMax + 1):
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">visited</span> = 0
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Calculate all combinations of propositions at size W and add to all_combinations</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">all_combinations</span> += [<span style="color: #006FE0;">frozenset</span>(props) <span style="color: #0000FF;">for</span> props <span style="color: #0000FF;">in</span> itertools.combinations(all_propositions, W)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Sanity check that this is 6279 for W=3, for example</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">"W="</span>,W,<span style="color: #008000;">"Combination count="</span>,<span style="color: #006FE0;">len</span>(all_combinations))
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Track, for each combination (by index), whether we have seen this combination before (0 for no, &gt;0 for yes)</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   seen_combinations: Set[FrozenSet[Proposition]] = <span style="color: #006FE0;">set</span>()
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Initialize seen_combinations</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   see_state(initial, all_combinations, seen_combinations)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   open_list: List[Tuple[<span style="color: #006FE0;">int</span>, State]] = [(0, initial)]
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   best_costs: <span style="color: #BA36A5;">Dict</span>[State, <span style="color: #006FE0;">int</span>] = {initial: 0}
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   best_from: Dict[State, List[<span style="color: #006FE0;">str</span>]] = {initial: []}
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">while</span> open_list:
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">cost</span>, <span style="color: #BA36A5;">state</span> = heapq.heappop(open_list)
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #BA36A5;">visited</span> += 1
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">I. This should look like your graph search (Dijkstra's is a nice choice), except...</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Call see_state on newly expanded states to update seen_combinations and use its return value to decide whether to add this state to the open list (is that the only thing that determines whether it should go on the open list?)</span>
<span style="color: #4C9ED9; background-color: #ffffff;"> </span>   <span style="color: #0000FF;">return</span> visited, -1, <span style="color: #D0372D;">None</span>

</pre>
</div>

<p>
Try it out like so:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Example</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Try harder ones once you have these down</span>

<span style="color: #0000FF;">print</span>(width_search({},{<span style="color: #008000;">'bench'</span>:1},4))
<span style="color: #0000FF;">print</span>(width_search({<span style="color: #008000;">'wood'</span>:1},{<span style="color: #008000;">'iron_pickaxe'</span>:1},4))
<span style="color: #0000FF;">print</span>(width_search({},{<span style="color: #008000;">'rail'</span>:1},4))
<span style="color: #0000FF;">print</span>(width_search({},{<span style="color: #008000;">'cart'</span>:1},4))
</pre>
</div>

<ol class="org-ol">
<li value="16">What&rsquo;s the largest planning problem (initial and goal state) you can think up which your algorithm can solve within 30 seconds?  How many nodes does it visit at its deepest \(W\) level, how high does \(WMax\) have to be, and how long does it take in seconds</li>
<li>How does increasing or decreasing the value of \(WMax\) change the time to find a solution, or: what sorts of craft planning situations benefit from increasing \(WMax\)?</li>
<li>Is iterative widening guaranteed to give optimal solutions for this problem?  In other words, does there exist a crafting problem where a width bound of \(w\) gives a suboptimal solution while \(w+1\) gives a better one?  What does this mean for implementing your algorithm&#x2014;where can you take shortcuts to get better performance if you already lost optimality, or can you not take such shortcuts?</li>
<li>Can you think of a way to apply iterative widening to the path planning problem?  Do you think it would perform better than A* there or worse?  Why?</li>
</ol>

<p>
Submit your Python files and reflections, and take a well-deserved rest!
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2018-08-23 Thu 00:00</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
